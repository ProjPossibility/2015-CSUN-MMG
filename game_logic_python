# -*- coding: utf-8 -*-
#Declare global direction variables
UP = 0
RIGHT = 1
DOWN = 2
LEFT = 3

#Read maze file and convert into binary array
import re

with open('maze_working.txt', 'r') as f:
    data = f.read()

lines = data.splitlines()

tiles_str = [re.findall("([0-99]+)", string) for string in lines]
tiles_bin = []
print tiles_str
for row in tiles_str:
   tiles_bin_row = []
   for tile in row:
        tiles_bin_row.append(bin(int(tile)))    
   tiles_bin.append(tiles_bin_row)
print tiles_bin

#interpret and split binary values from maze array to form final tileset
tiles = []
for row in tiles_bin:
    tiles_row = []    
    for tile in row:
        chars = []        
        string = str(tile).replace('0b','')
        print string        
        if len(string) < 6:
            for num in range(6-len(string)):
                chars.append(0)
        for char in string:
            chars.append(int(str(char)))
        tiles_row.append(chars)
    tiles.append(tiles_row)

print tiles
print len(tiles)

#store tiles list in  for easy indexing
tiles_dict = {}
for row in tiles:    
    for tile in row:
        occurrences = [i for i,j in enumerate(row) if j == tile]
        for item in occurrences:
            tiles_dict[str(tiles.index(row))+str(item)] = tile
print tiles_dict

class Game:    
    def __init__(self, game_tiles, num_players, state):
        self.tiles = game_tiles
        self.num_players = num_players
        self.state = 0
    def update_state():
        pass
    

class Player:
    def __init__(self, location, facing):
        #location should be passed as a string        
        self.location = location
        self.facing = facing
        self.current_tile = tiles_dict[location]
        
    def update_location(self, new_location):
        self.location = new_location
        self.current_tile = tiles_dict[new_location]
    
    def check_if_wall(self,direction):
        if self.current_tile[direction] == 0:
            return False
        else:
            return True
            
    def look(self,direction):
        if self.check_if_wall(direction):
            #response for wall
            pass
        elif not self.check_if_wall(direction):
            #response for no wall
            pass
        
    def move(self,direction):
       if not self.check_if_wall(direction):
            if direction == 0:
                self.update_location(str(int(self.location[0])-1)+self.location[1])
            elif direction == 1:
                self.update_location(self.location[0]+str(int(self.location[1])+1))
            elif direction == 2:
                self.update_location(str(int(self.location[0])+1)+self.location[1])
            elif direction == 3:
                self.update_location(self.location[0]+str(int(self.location[1])+1))

bob = Player('02',0)
print bob.location
print bob.current_tile
bob.move(0)
print bob.location
bob.move(1)
print bob.location
print bob.current_tile
bob.move(3)
print bob.location
print bob.current_tile
bob.move(2)
print bob.location
